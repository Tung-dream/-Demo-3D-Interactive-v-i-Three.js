<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo 3D Interactive - Three.js</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: Arial, sans-serif;
        }
        
        h1 {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 1000;
            margin: 0;
            font-size: 24px;
        }
        
        #modelSelect {
            position: absolute;
            top: 50px;
            left: 10px;
            z-index: 1000;
            font-size: 16px;
            padding: 8px;
            border-radius: 4px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
        }
        
        #loading {
            position: absolute;
            top: 90px;
            left: 10px;
            color: white;
            font-size: 18px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .dg.ac {
            z-index: 1001 !important;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ® Demo 3D Interactive vá»›i Three.js</h1>
    
    <select id="modelSelect">
        <option value="duck">ðŸ¦† Duck (Default)</option>
        <option value="robot">ðŸ¤– Robot</option>
        <option value="car">ðŸš— Car</option>
        <option value="avocado">ðŸ¥‘ Quáº£ BÆ¡</option>
    </select>
    
    <div id="loading" style="display: none;">Loading model...</div>
    
    <div id="controls">
        <strong>Controls:</strong><br>
        â†‘â†“ Arrow Keys: TÄƒng/Giáº£m tá»‘c Ä‘á»™<br>
        R/G/B/Y: Thay Ä‘á»•i mÃ u<br>
        D: LÃ m váº­t thá»ƒ nháº£y<br>
        Click objects: Random colors<br>
        Mouse: Orbit camera
    </div>

    <!-- Load Three.js libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 150);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111111);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.target.set(0, 0, 0);

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.5);
        pointLight.position.set(50, 50, 50);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 2048;
        pointLight.shadow.mapSize.height = 2048;
        scene.add(pointLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0xffffff, 1);
        spotLight.position.set(10, 20, 10);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // Create basic shapes
        const geometry = new THREE.BoxGeometry(35, 35, 35);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, 
            metalness: 0.5, 
            roughness: 0.5 
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        const sphereGeometry = new THREE.SphereGeometry(25, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0000ff, 
            metalness: 0.5, 
            roughness: 0.5 
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(0, -20, 0);
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        scene.add(sphere);

        const coneGeometry = new THREE.ConeGeometry(25, 50, 32);
        const coneMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffff00, 
            metalness: 0.5, 
            roughness: 0.5 
        });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.set(60, 0, 0);
        cone.castShadow = true;
        cone.receiveShadow = true;
        scene.add(cone);

        // Ground plane
        const planeGeometry = new THREE.PlaneGeometry(500, 500);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x404040, 
            transparent: true, 
            opacity: 0.3 
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -80;
        plane.receiveShadow = true;
        scene.add(plane);

        // Model loading setup
        const loader = new THREE.GLTFLoader();
        const loadingDiv = document.getElementById('loading');
        
        // Fixed modelURLs object - keys match select options
        const modelURLs = {
            'duck': 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb',
            'robot': 'https://cdn.jsdelivr.net/gh/google/model-viewer@master/packages/shared-assets/models/RobotExpressive.glb',
            'car': 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb',
            'avocado': 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF-Binary/Avocado.glb'
        };

        let currentModel = null;
        let interactiveObjects = [cube, sphere, cone]; // Declare before use

        function loadModel(modelName) {
            if (currentModel) {
                scene.remove(currentModel);
                // Remove from interactive objects
                interactiveObjects = interactiveObjects.filter(obj => 
                    obj === cube || obj === sphere || obj === cone
                );
                currentModel = null;
            }

            loadingDiv.style.display = 'block';
            loadingDiv.textContent = `Loading ${modelName} model...`;

            const modelUrl = modelURLs[modelName];
            
            if (!modelUrl) {
                console.error(`No URL found for model: ${modelName}`);
                loadingDiv.textContent = `No URL for ${modelName} model ðŸ˜¢`;
                setTimeout(() => {
                    loadingDiv.style.display = 'none';
                }, 3000);
                return;
            }
            
            loader.load(
                modelUrl,
                function (gltf) {
                    currentModel = gltf.scene;
                    
                    // Scale and position based on model type
                    switch(modelName) {
                        case 'duck':
                            currentModel.scale.set(20, 20, 20);
                            currentModel.position.set(-80, -30, 0);
                            break;
                        case 'robot':
                            currentModel.scale.set(30, 30, 30);
                            currentModel.position.set(-80, -50, 0);
                            break;
                        case 'car':
                            currentModel.scale.set(8, 8, 8);
                            currentModel.position.set(-80, -45, 0);
                            break;
                        case 'avocado':
                            currentModel.scale.set(100, 100, 100);
                            currentModel.position.set(-80, -60, 0);
                            break;
                    }

                    // Enable shadows and add to interactive objects
                    currentModel.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            interactiveObjects.push(child);
                        }
                    });

                    scene.add(currentModel);
                    loadingDiv.style.display = 'none';
                    console.log(`${modelName} loaded successfully!`);
                },
                function (progress) {
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        loadingDiv.textContent = `Loading ${modelName}... ${percent}%`;
                    }
                },
                function (error) {
                    console.error(`Error loading ${modelName}:`, error);
                    loadingDiv.textContent = `Failed to load ${modelName} model ðŸ˜¢`;
                    setTimeout(() => {
                        loadingDiv.style.display = 'none';
                    }, 3000);
                }
            );
        }

        // Model selection event
        document.getElementById('modelSelect').addEventListener('change', function () {
            const selected = this.value;
            loadModel(selected);
        });

        // Load default model
        loadModel('duck');

        // Animation variables
        let rotationSpeed = 0.01;
        let direction = 1;

        // Keyboard controls
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    rotationSpeed = Math.min(0.1, rotationSpeed + 0.01);
                    console.log('Rotation speed increased:', rotationSpeed);
                    break;
                case 'ArrowDown':
                    rotationSpeed = Math.max(0, rotationSpeed - 0.01);
                    console.log('Rotation speed decreased:', rotationSpeed);
                    break;
                case 'r':
                case 'R':
                    cube.material.color.set(0xffffff);
                    sphere.material.color.set(0x00ff00);
                    cone.material.color.set(0xffff00);
                    break;
                case 'g':
                case 'G':
                    cube.material.color.set(0xff69b4);
                    sphere.material.color.set(0xffa500);
                    cone.material.color.set(0xffffff);
                    break;
                case 'b':
                case 'B':
                    cube.material.color.set(0xff0000);
                    sphere.material.color.set(0x808080);
                    cone.material.color.set(0xFFD700);
                    break;
                case 'y':
                case 'Y':
                    cube.material.color.set(0x8B4513);
                    sphere.material.color.set(0x00ff00);
                    cone.material.color.set(0xff69b4);
                    break;
                case 'd':
                case 'D':
                    if (currentModel) {
                        const originalY = currentModel.position.y;
                        currentModel.position.y += 30;
                        setTimeout(() => {
                            if (currentModel) currentModel.position.y = originalY;
                        }, 500);
                    }
                    break;
            }
        });

        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            // Check if click is on GUI
            if (event.target.closest('.dg')) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.material && clickedObject.material.color) {
                    const randomColor = Math.random() * 0xffffff;
                    clickedObject.material.color.set(randomColor);
                    console.log('Object color changed! ðŸŽ¨');
                }
            }
        });

        // GUI Controls
        const gui = new dat.GUI();
        
        const colors = {
            cubeColor: '#ff0000',
            sphereColor: '#0000ff',
            coneColor: '#ffff00',
            backgroundColor: '#111111'
        };

        const guiControls = {
            rotationSpeed: rotationSpeed,
            autoMove: true,
            modelJump: function() {
                if (currentModel) {
                    const originalY = currentModel.position.y;
                    currentModel.position.y += 30;
                    setTimeout(() => {
                        if (currentModel) currentModel.position.y = originalY;
                    }, 500);
                }
            },
            resetColors: function() {
                cube.material.color.set(0xff0000);
                sphere.material.color.set(0x0000ff);
                cone.material.color.set(0xffff00);
                colors.cubeColor = '#ff0000';
                colors.sphereColor = '#0000ff';
                colors.coneColor = '#ffff00';
                gui.updateDisplay();
            }
        };

        // GUI folders
        const colorFolder = gui.addFolder('Colors');
        colorFolder.addColor(colors, 'cubeColor').name('Cube').onChange((value) => {
            cube.material.color.set(value);
        });
        colorFolder.addColor(colors, 'sphereColor').name('Sphere').onChange((value) => {
            sphere.material.color.set(value);
        });
        colorFolder.addColor(colors, 'coneColor').name('Cone').onChange((value) => {
            cone.material.color.set(value);
        });
        colorFolder.addColor(colors, 'backgroundColor').name('Background').onChange((value) => {
            renderer.setClearColor(value);
        });

        const controlFolder = gui.addFolder('Controls');
        controlFolder.add(guiControls, 'rotationSpeed', 0, 0.1).name('Rotation Speed').onChange((value) => {
            rotationSpeed = value;
        });
        controlFolder.add(guiControls, 'autoMove').name('Auto Movement');
        controlFolder.add(guiControls, 'modelJump').name('Model Jump! ðŸš€');
        controlFolder.add(guiControls, 'resetColors').name('Reset Colors');

        colorFolder.open();
        controlFolder.open();

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Rotate objects
            cube.rotation.x += rotationSpeed;
            cube.rotation.y += rotationSpeed;
            sphere.rotation.x += rotationSpeed;
            sphere.rotation.y += rotationSpeed;
            cone.rotation.x += rotationSpeed;
            cone.rotation.y += rotationSpeed;

            // Rotate current model
            if (currentModel) {
                currentModel.rotation.y += rotationSpeed * 0.5;
            }

            // Auto movement
            if (guiControls.autoMove) {
                // Oscillating movement for basic shapes
                cube.position.x = Math.sin(time) * 50;
                cube.position.y = Math.cos(time * 0.5) * 30;
                
                sphere.position.x = Math.cos(time * 0.8) * 40;
                sphere.position.z = Math.sin(time * 0.6) * 30;
                
                cone.position.y = Math.sin(time * 1.2) * 25;
                cone.position.z = Math.cos(time * 0.4) * 35;

                // Model floating effect
                if (currentModel) {
                    currentModel.position.x = Math.sin(time * 0.8) * 20 - 80;
                    currentModel.position.z = Math.cos(time * 0.6) * 15;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>